//位操作符只适用于整形----浮点型不适应
//所以在实际的运用中--一般运用创建临时变量的方法



//编写代码实现：求一个整数存储在内存中的二进制中的1的个数
//求补码的的二进制位中1的个数

//int a=3;
//00000000000000000000000000000011
//
//a&1
//
//00000000000000000000000000000011  3
//00000000000000000000000000000001  1
//00000000000000000000000000000001  a&1
//这样就知道了最低位是0还是1
//之后再用右移操作符--》

//5.赋值操作符
//赋值操作符可以修改之前不满意的值
//‘=’
//#include<stdio.h>
//int main()
//{
//	int a = 3;//这个是初始化，不是赋值
//	int x = 10, y = 20;
//	a = x = y + 1;//可以连续赋值----但是不建议这样写
//	return 0;
//}
//复合赋值符
//+= -= /=  %= &= |=    与一般的操作符效率相等



//单目操作符--只有一个操作数
//双目操作符--有两个操作数
//‘！’
//int main()
//{
//	int flag = 3;//flag本来为真；因为非零
//
//	if (!flag)
//	{
//		//flag为假则进入if
//	}
//	return 0;
//}

//‘-’---取负
//‘+’

//‘&’取地址操作符
//‘sizeof’---sizeof(a)---计算的是a（变量）所占的内存的大小/或者计算类型所创建的变量所占据空间的大小，单位是字节--


//‘~’--按位取反
//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	printf("%d", ~a);//结果为-1
//
//	//分析
//	//0000000000000000000000000000  a=0的补码
//	//1111111111111111111111111111  ~a的补码
//	//1111111111111111111111111110  减1后的结果
//	//1000000000000000000000000001  原码为-1
//
//	int b = 3;
//	printf("%d", ~b);//结果为-4
//
//	//分析
//	//0000000000000000000000000011
//    //1111111111111111111111111100
//	//1111111111111111111111111011
//	//1000000000000000000000000100  -4
//
//	return 0;
//
//}

////想要把特定位置上的0变为1
//#include<stdio.h>
//
//int main()
//{
//	int a = 13;
//	a |= (1 << 1);
//	printf("%d\n", a);
//
//	//00000000000000000000000000001101
//	//想要变成
//	//00000000000000000000000000001111
//
//	//00000000000000000000000000001101---13
//	//00000000000000000000000000000001---1
//	//先让1向左移1位变成
//	//00000000000000000000000000000010
//	// 再让变之后的与13进行按位或计算
//	//最后变为
//	//00000000000000000000000000001111---15
//
//
//
//
//	return 0;
//}



//想要把特定位置上的1变为0
//#include<stdio.h>
//
//int main()
//{
//	int a = 13;
//	a &= (~(1 << 3));
//	printf("%d\n", a);//woo,结果就是5
//
//	//00000000000000000000000000001101
//	//想要变成
//	//00000000000000000000000000000101
//
//	//00000000000000000000000000001101---13
//	//00000000000000000000000000000001
//	//先让1向左移3位变成
//	//00000000000000000000000000001000
//	// 再让变之后的按位取反变为
//	//11111111111111111111111111110111
//	//最后与13进行按位与计算
//	//00000000000000000000000000000101--5
//
//
//
//
//	return 0;
//}












//间接访问操作符（解引用操作符）
//#include<stdio.h>
//
//int main()
//{
//	int a = 10;
//	int* p = &a;//int*是一种指针类型
//	*p=20;//解引用操作---通过p的地址找到对象  //这句话相当于a=20----*p等价与存的地址的那个变量
//	//取地址和*是一对的
//	printf("%d", a);
//	return 0;
//}



//强制类型转换
//#include<stdio.h>
//
//int main()
//{
//	int a = (int)3.14;
//	printf("%d", a);//结果为3
//
//	srand((unsigned int)time(NULL));
//	//time_t 是longlong类型的
//
//	return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	int a = 10;
//	printf("%d", sizeof(a));
//	printf("%d", sizeof(int));
//	//正常情况下是按照上面的写法写的
//	//但是小括号可不可以省略呢
//	printf("%d", sizeof a);//函数在调用的时候（）不能省略，但是sizeof不是函数，所以这个地方的（）可以省略
//	//printf("%d", sizeof int);  //这里不能这么写，会报错
//
////sizeof不是函数，是操作符    
////strlen是库函数，是用来求字符串长度的（）不能省略
//	return 0;
//}


////小小的练习
//void text1(int arr[])
//{
//	printf("%d", sizeof(arr));//2.
//}
//
//void text2(int ch[])
//{
//	printf("%d", sizeof(ch));//4.
//}

//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//
//	printf("%d", sizeof(arr));//1.
//	printf("%d", sizeof(ch));//3.
//
//	text1(arr);
//	text2(ch);
//
//	return 0;
//}

//问：这里的1234，分别的输出结果是什么？
//1.40
//2.4-----这两个没有问题---主要是考察传的是第一个元素的地址--即void text1(int arr[])---这里的int arr【】看似是数组实际是指针
//3.10----这个也没有问题--因为字符型数据的一个占用一个字节
//4.4-----这个就出问题了---为什么不是1呢？---其实不管存放的是什么类型的数据，只要是指针变量就占4个字节---因为地址是一串数据吗，要存放这一串数据所要占用的空间是一定的
//指针变量的内存大小是固定的----4个字节




//7.关系操作符

//重点注意==就可以了
//#include<stdio.h>
//int main()
//{
//	if ("abc" == "abcdef")//这样写不是在比较两个字符串的内容，而是在比较2个字符串的首字符的地址
//	{
//
//	}
//	//两个字符串的比较应该使用strcmp
//	return 0;
//}


//8.逻辑操作符

//‘&&’逻辑与
//‘||’逻辑或
//与按位与或区分开---逻辑与或只关注真假

//#include<stdio.h>
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a && b;
//	printf("%d", c);//c=1----真  //并且
//	int d = 0;
//	 c = a && d;//c=0
//	int e = a || b;
//	printf("%d", e);//e=1   //或者
//	return 0;
//}


//如果逻辑&&操作符左边的表达式是假的话，右边的表达式不执行
//如果逻辑||操作符左边的表达式是真的话，右边的表达式不执行
//#include<stdio.h>
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;//这里的a++先给值再++，所以a的值为0，是假，后面的b++，d++都没有执行
//	//i = a++ || ++b || d++;//-----结果变为---1334
//	printf("%d %d %d %d", a, b, c, d);//结果为1234--&&的时候
//	return 0;
//}


//条件操作符（三目操作符）
//（表达式1） ？ （表达式2） ：（表达式3）
//表达式1若为真，表达式2算，表达式3不算，表达式2的结果为整个表达式的结果
//表达式1若为假，表达式2不算，表达式3算，表达式3的结果为整个表达式的结果
//#include<stdio.h>
//int main()
//{
//	int a = 3, b,c;
//	(a > 5) ? (b = 1) : (b = 2);
//	//或者写为
//	b = (a > 5 ? 1 : 3);
//
//	//比大小
//	c = (a > b ? a : b);
//	return 0;
//}


//逗号表达式
//是由逗号隔开的一串表达式
//从左到右依次执行，整个表达式的结果是最后一个表达式的结果

//下标引用，
//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	arr[7] = 8;//这里的方块【】就是下标引用操作符---操作数为arr和7
//	//3+5与5+3是一样的，那么arr和7可不可以交换呢
//	7[arr] = 9;//通过调试发现是可以的-----更加印证了【】是一个操作符
//
//	//arr[7]可以写为*(arr+7)
//    //arr是数组首元素的地址
//	//arr+7是跳过了7个元素，指向了第8个元素
//	//即*(arr+7)就是第8个元素
//	//加法交换率 *(arr+7)=*(7+arr)----->arr[7]=7[arr]
//	//但是并不建议这样写，会使别人看不懂
//
//}

//函数调用操作符（），不能省，Add(int x,int y)操作数是Add，a，b----操作数至少有1个

//第71节最后没听懂------讲完指针和结构体后回看这一部分
//.操作符  ->操作符
//结构体(对象).成员    ss.name
//结构体(指针)->成员   ps->name(相当于(*ps).name)  //通过ps先找到对象（解引用），再操作
#include<string.h>///要用结构体需要引的头文件

struct Stu
{
	char name[20];
	int age;
	double score;
};


//改之前的代码
//void set_stu(struct Stu ss)//要想给ss里面放数据
//{
//	strcpy(ss.name , "yiran");//name是一个地址，不能把“”付给地址
//	ss.age = 20;
//	ss.score = 100.0;
//
//}
//void print_stu(struct Stu ss)//要想给ss里面放数据---临时拷贝到ss里（不会对s产生影响）
////要是希望把s的值改动---Stu*ps
//{
//	printf("%s %d %lf", ss.name, ss.age, ss.score); //传参出了问题--name age score为对象
//	//
//
//}

//改之后的代码
//把地址传过去---真正影响了s的值
//void set_stu(struct Stu *ps)
//{
//	strcpy((*ps).name, "yiran");
//	(*ps).age = 20;
//	(*ps).score = 100.0;
//
//}
//void print_stu(struct Stu(*ps))
////要是希望把s的值改动---Stu*ps
//{
//	printf("%s %d %lf", (*ps).name, (*ps).age, (*ps).score); //这样就可以了
//}
//还是太麻烦了
//要简化

//简化获得的代码
void set_stu(struct Stu* ps)
{
	strcpy(ps->name, "yiran");
	ps->age = 20;
	ps->score = 100.0;  

}
void print_stu(struct Stu(*ps))
{
	printf("%s %d %lf", ps->name, ps->age, ps->score; //这样就可以了
}


int main()
{
	struct Stu s = { 0 };
	set_stu(s);
	printf_stu();
	return 0;
}



//表达式求值
//操作符最重要的运用是表达式

//表达式求值的顺序一部分是由操作符的优先级和结合性决定
//同样，有些表达式的操作数在求值的过程中可能需要转化为其他类型

//#include<stdio.h>
//int main()
//{
//	int b = 2 + 3 + 4;//优先级相同，看结合性--L/R--即为从左到右结合，先算2+3=5，再算5+4=9
//	return 0;
//}

//隐式类型转换
//C的整形算数运算总是以缺省类型的精度来进行的----缺省（即默认）
//为了提升这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通整形，这种转化类型称为整形提升

//整形提升的意义
//表达式的整形运算要在CPU的相应运算器件内执行，CPU内整形运算器一般就是int字节的长度，同时也i是
//CPU通用寄存器的长度，因此，即使两个char类型的相加，在CPU执行时实际上也要先转化为CPU内整形操作数
//的长度-----总之是为了提高通用性


//自己能看见的都是原码的
//但是在计算机内存的都是补码的


//如何进行整形提升--是按照变量的数据类型的符号位来进行提升的
//如果无符号--直接在高位补0
//如果数据太大而放不下到char类型中，会被截断（只留下8bite，剩下的丢了，再按照符号位进行提升）
//#include<stdio.h>
//int main()
//{
//	char c = -1;//-1是整数，32个比特位
//	//10000000000000000000000000000001   -1
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111--》-1的补码
//	//变量c的二进制位因为是char类型，所以只有8个bite位  11111111
//	//因为char为有符号的char
//	//所以在整型提升的时候，高位补充符号位，即为1
//	//提升之后的结果是
//	//11111111111111111111111111111111
//	return 0;
//}



//int 4
//char 1
//#include<stdio.h>
//int main()
//{
//	char a = 5;
//	//00000000000000000000000000000101
//	//只存
//	//00000101---符号位0表示正数
//
//	char b = 126;
//    //000000000000000000000000001111110
//	//只存
//	//01111110
//
//	char c = a + b;//a,b,在运算之前先变为普通整形--char类型达不到普通整形的大小--先整形提升再参与运算
//	//00000101--a
//	//01111110--b
//	//a+b达不到一个整形的大小---会发生整形提升
//	//00000000000000000000000000000101---a提升
//	//00000000000000000000000001111110---b提升
//	//提升后再计算
//	//00000000000000000000000010000011---相加之后
//	// 只存
//	//10000011---c
//	//c整形提升
//	//11111111111111111111111110000011---c的补码
//	//11111111111111111111111110000010
//	//10000000000000000000000001111101---c的原码----》-125
//	printf("%d", c);//c=-125
//	return 0;
//}

//验证整形提升确实存在
//#include<stdio.h>
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb600000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb600000)
//		printf("c");//结果只打印了c---说明确实进行了整形提升--》char类型和short类型都不够int类型的大小
//
//	
//	return 0;
//}

//若变成unsigned类型呢---只是在高位补0---与原来并没有区别
//#include<stdio.h>
//int main()
//{
//	unsigned char a = 0xb6;//10110110---》00000000000000000000000010110110----没区别
//	unsigned short b = 0xb600;
//	int c = 0xb600000;
// 
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb600000)
//		printf("c");//结果打印了abc
//
//	return 0;
//}

//另一个例子证明整形提升
//#include<stdio.h>
//int main()
//{
//	char c = 1;
//
//	printf("%u\n", sizeof(c)); //1
//	printf("%u\n", sizeof(+c));//4---整形提升
//	printf("%u\n", sizeof(-c));//4---整形提升
//
//	return 0;
//}



//算数转换
//上面讲的是类型小于int类型的，如果大于int 类型，就要进行算数转换

//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//向上转换--向大的类型转换


//操作符的属性
//复杂表达式的求值有3个影响的因素
//1.操作符的优先级
//2。操作符的结合性
//3.是否控制求值顺序

//相邻操作符--看优先级
//优先级相同--看结合性
//算数操作符  关系操作符 位操作符 逻辑操作符 赋值操作符 逗号表达式-----优先级从大到小

//只有 逻辑与或  条件操作符  逗号表达式 控制求值顺序

//即使有了一个表达式的所有属性，依然有可能写不出表达式确定的运算顺序-----》问题表达式

// a*b+c*d+e*f  ----》 1.先算所有*，再算所有的+    2.算一个*，算一个+  好像都可以--》这样会出问题
// 通过加上（）
// 
// c + --c   --c的优先级更高，但是--c会影响c的值，不知道c的值在什么时候准备好的（不知道c加前还是加后）---所以是一个问题表达式
//       
// 


//a=fun()+fun()*fun()---不知道谁先调用----这也是一个错误代码

//#include<stdio.h>
//int main()
//{
//	int a = 1;
//	int b = (++a) + (++a) + (++a);
//	printf("%d", b);//结果12，但是在不同的编译器下结果不同
//
//}






//指针
//指针是什么
//1.指针是内存中一个最小单元的编号，也就是地址
//2.平时口语中说的指针，通常说的是指针变量，是用来存放内存地址的变量

//内存如何管理呢？
//切割成内存单元--1字节byte---如何找到---进行编号（称为地址）
//地址也叫指针

//int main()
//{
//	int a = 0;//a是整形变量，占4个字节的内存空间
//	//取地址a的时候其实取的是第一个地址----地址其实是一个数值--可以存起来
//	int* pa = &a;
//	//pa是一个变量，用来存放地址的
//	//口语上，一般称这个pa为指针（实际上是一个指针变量，是用来存放地址的）
//	//本质上，指针就是地址
//	return 0;
//}
//指针的大小在32位机器上是4个字节，在64位的平台上是8个字节




//指针和指针类型
//X86是32位的环境
//X64是64位的环境


//#include<stdio.h>
//int main()
//{
//	char* pc = NULL;
//	short* ps = NULL;
//	int* pi = NULL;
//	double* pd = NULL;
//
//	printf("%u\n", sizeof(pc));
//	printf("%u\n", sizeof(ps));
//	printf("%u\n", sizeof(pi));
//	printf("%u\n", sizeof(pd));//打印的都是8
//	//如果改为X86---打印的都是4
//	//反正都是一样的大小---为什么不创建一个能囊括所有类型的统一的指针类型呢
//	//指针类型的意义
//return 0;
//}


//指针类型的意义

#include<stdio.h>
int main()
{

	int a = 0X11223344;//正好可以存下--4个字节
	return 0;

}




