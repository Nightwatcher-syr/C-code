
//自定义类型：结构体，联合体，枚举

//结构体
//结构的自引用
//结构体变量的定义和初始化
//结构体内存对齐
//结构体传参
//结构体实现尾端（位段的填充&可移植性）

//结构---是一些值的集合，这些值称为成员变量，结构的每一个成员可以是不同类型的变量


//结构的声明
//struct tag
//{
//	member-list;
//};variable - list;

//结构体类型的定义

//学生
// 1.第一种写法
//struct Stu
//{
//	//描述学生的相关属性
//	//下面仅仅是创建了一个类型（就像int，float等等一样），所以不用初始化
//	char name[20];
//	int age;
//};

// 1.第二种写法
//struct Stu
//{
//
//	char name[20];
//	int age;
//}s1,s2;//s1,s2是struct Stu类型的变量--全局变量
//
//int main()
//{
//	struct Stu s3;//局部变量
//	return 0;
//}
//
//
////特殊结构体声明
////1.匿名结构体类型---只能使用一次
////（编译器支持）
//struct         //名字不写
//{
//
//	char name[20];
//	int age;
//}s1;//只能使用这一次，顺带创建的变量
//
//int main()
//{
//	return 0;//没法创建新的变量了--没有名字无法再次使用
//}
//
//
////一个匿名结构体类型的例子
//struct         
//{
//
//	char name[20];
//	int age;
//}x;
//
//struct        
//{
//
//	char name[20];
//	int age;
//}a[20],*p;    //(结构体加上*是一个整体--结构体指针)
//
//int main()
//{
//	p = &x;//这样运行起来编译器会报一个警告--从*到*的了类型不兼容（虽然以上两个结构体的成员一模
//           //一样，但是编译器还是认为以上两个匿名结构体是两个不同的类型	）
//	return 0;
//}
//
////结构体的自引用
////数据结构---数据在内存中的存储结构{线性【顺序表（连续存放1，2，3，4，5）,链表（1能够找到2，2能够找到3）】，树形，}
////1，2，3，4，5存放的位置叫节点
//
//
//
////第一次尝试:一个节点中包含下一个节点----错误
////struct Note
////{
////	int date;
////	struct Note next;
////};
////
////int main()
////{
////	sizeof(struct Note);
////	return 0;
////}
//
////第二次尝试:一个节点中包含下一个节点的地址
//struct Note
//{
//	int date;
//	struct Note* next;//一个节点中包含两个部分：1.数据域   2.指针域（下一个节点的地址）
//};
//
//int main()
//{
//	sizeof(struct Note);
//	return 0;
//}//这就是结构体的自引用
//
//
////一个不可行的写法（先有鸡还是先有蛋的问题）
//typedef struct
//{
//	int data;
//	Note* next;
//}Note;
////
//// 这个代码的意思是把一个匿名的结构体类型重新起一个名字叫Note，然后再取Note的地址（不认识Note类型）
////
//
////改善--不用匿名结构体类型
//typedef struct Node
//{
//	int data;
//	Note* next;
//}Note;
//
//
////1.
//typedef struct Node
//{
//	int data;
//	Note* next;
//}*linklist;
////意思是，先创建了struct类型，再对struct*类型的指针重命名为linklist
//
//
////2.（与1的效果一致）
//struct Node
//{
//	int data;
//	Note* next;
//};
//typedef struct Node* linklist;
//
//
////初始化
//
////1.
//struct Point
//{
//	int x;
//	int y;
//}p1={2,3};
//
////struct Point
////{
////	int x;
////	int y;
////}             -----类型（图纸）
//
//
////p1 = { 2,3 }  -----变量（照着图纸盖房子）  及初始化
//

//2.
struct Point
{
	int x;
	int y;
}p1 = { 2,3 };

struct score
{
	int n;
	char ch;
};
struct Stu
{
	struct score s;
	char name[20];
	int age;
};

int main()
{
	struct Point p2 = { 3,4 };
	struct Stu s1 = { "asd",20,{100,'q'} };   //只要是结构体，初始化的时候就要用{}--所以要{}里面加{}
	printf("%s %d %d %c\n", s1.name, s1.age, s1.s.n, s1.s.ch);
}

//结构体内存对齐   
// 
// 结构体的对齐规则
// 1.第一个成员在结构体变量偏移量为0的地址处
// 2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
//   对齐数=编译器默认的一个对齐数与该成员大小的较小值（VS默认为8）----只有VS有默认对齐数
// 3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍
// 4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍
//                                                                                                          

struct S1
{
	char c1;
	int i;
	char c2;
};
//offsetof----返回一个结构体类型第一个成员与所给成员之间的偏移量（std）

//平台原因
//性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐
//原因在于：为了访问未对齐的内存，处理器需要两次内存访问，而对齐的内存访问仅仅需要一次（32位机器一次访问4个字节
// 但是会浪费
//让占用空间小的成员尽量集中在一起---一定程度上减少浪费

//拿空间换时间


//默认对齐数可修改
#pragma pack(4)
#pragma pack(1)  //不会浪费空间

#pragma pack()// ----- 恢复





