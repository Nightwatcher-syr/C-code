//指针类型的意义
//1.//----指针类型是有意义的
	//指针变量的类型决定了指针在被解引用的时候访问几个字节
	//如果是int*的指针，解引用访问4个字节
	//如果是char*的指针，解引用访问1个字节
	//推广到其他类型
//int main()
//{
//	int a = 0X11223344;//一个16进制数字能表示为4个二进制位
//	int*pa=&a;//通过监视看到pa的地址存放的是44332211----虽然是倒着的，但是确实是a的内容
//	*pa = 0;//通过pa找到a的地址把0赋给a
//
//	char* pc = &a;//理论上取地址a的类型应该是int*类型的
//	//char*是4个字节，应该也能存下a的地址
//	//存的时候没有差异
//	//但是用的时候有差异
//
//	//用监视查看char*pc的地址----看到存的是00332211-----？？？？不对呀，怎么回事，出问题了
//	//----指针类型是有意义的
//	//指针变量的类型决定了指针在被解引用的时候访问几个字节
//	//如果是int*的指针，解引用访问4个字节
//	//如果是char*的指针，解引用访问1个字节
//	//推广到其他类型
//	//。。。
//
//	return 0;
//}


//指针类型的意义
//2.
//指针的类型决定了指针+1-1操作的时候，跳过几个字节
//即决定了指针的步长

//char*类型一次访问1个字节
//int*类型一次访问4个字节
//所以说程序员可根据自己一次需要访问的字节数来决定指针的类型

//指针变量的大小（固定4个字节）和指针变量里面存的地址（可以是多个不同字节）是两个概念


//#include<stdio.h>
//
//int main()
//{
//	int a = 0X11223344;
//	int* pa = &a;
//	char* pc = &a;
//	printf("%p\n", pa);
//	printf("%p\n", pc);
//	//000000CF75F5FA74
//	//000000CF75F5FA74----一模一样
//	printf("%p\n", pa+1);
//	printf("%p\n", pc+1);
//	//00000060B2D9F818--  +4
//	//00000060B2D9F815--  +1   结果不一样了
//	//这里就跟类型有关系了
//
//	return 0;
//}


//问题来了，float和int一次跳过的大小都是4个字节----那么这两个是否可以通用
//不可以
//#include<stdio.h>
//
//int main()
//{
//	int a = 0X11223344;
//	int* pa = &a;
//	float* pf = &a;
//	*pa = 100;//64000000
//	*pf = 100.0;//0000cb42
//	//不一样---原因是float*是按照float的类型来存放的
//	//内存对这两个类型的解读不一样
//	return 0;
//}


//再次解释
//32位机器的地址（一串字符或数字）是4个字节-----即存放这样一个地址（这一串字符或数字）需要4个字节
//64位机器的地址（一串字符或数字）是8个字节-----即存放这样一个地址（这一串字符或数字）需要8个字节

//但是一个地址可以访问的字节数由指针的类型决定
//如一个double*类型的指针的权限是访问8个字节


//举个形象的比喻
//地址就是门牌（A小区门牌号都是需要一块石头板子来写）-----32位机器的地址（一串字符或数字）是4个字节
//地址就是门牌（B小区门牌号都是需要一块木头板子来写）-----64位机器的地址（一串字符或数字）是8个字节
// 
//而A小区中不同的门牌号码对应的户型不同   但是一个地址可以访问的字节数由指针的类型决定
//有的户型是别墅                          如一个double*类型的指针的权限是访问8个字节
// 有的户型是小洋房                       如一个int*类型的指针的权限是访问4个字节
// 有的户型是90平小房子                   如一个char*类型的指针的权限是访问1个字节


//野指针
//野指针就是指指针执行的位置是不可知的（随机的，不正确的，没有明确限制的）

//1.指针未初始化
//#include<stdio.h>
//int main()
//{
//	int* p;
//	//p没有初始化----就意味着没有明确的指向
//	//一个局部变量不初始化的话，放的是随机值：0Xcccccccc----把这样一个地址当成了p的地址
//	
//	*p = 10;//非法访问内存了，这里的p就是野指针
//	 
//}

//2.指针越界访问
//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	int*p=arr;//arr[0]的地址
//	int i = 0;
//	for (i = 0;i <= 0;i++)//第十次的时候越界了--当指针指向的范围超出野指针的范围时，p就是野指针
//	{
//		*p = arr;
//		p++;
//	}
//	return 0;
//
//}

//3.指针指向的空间释放


//int*text()
//{
//	int a = 10;
//	return &a;
//}
//
//#include<stdio.h>
//
//int main()
//{
//	int*p=text();//返回a的地址的时候，p记住了这个空间，但是这时函数的空间释放了（函数的变量是临时变量，用后会回收）
//	return 0;
//
//}


//避免野指针的出现
// 
//1.明确给指针初始化（在知道应该初始化什么值的时候）
//2.若不知道，则初始化为NULL空指针
//3.小心指针越界
//4.指针指向空间释放即设置NULL
//5.避免返回局部变量的地址
//6.指针使用之前检查其有效性

//但是，野指针是无法完全被避免的---小心

//#include<stdio.h>
//int main()
//{
//	int b = 0;
//	int a = 10;
//	int* p = &a;
//	int* p2 = NULL;
//
//	int* p = 20;//这样没问题
//	*p2 = 100;//这样写程序会崩溃，零地址是不能被访问的，*p2没有指向有效的空间---所以这样使用是错误的
//
//	int* p3 = NULL;
//	if (p3 != NULL)//建议这样写
//	{
//		*p3 = 100;//这样是可以的
//	}
//
//	return 0;
//
//}

////---
//int*text()
//{
//	int a = 10;
//	return &a;
//}
//
//#include<stdio.h>
//
//int main()
//{
//	int*p=text();
//	if (p != NULL)
//	{
//		printf("%d\n", *p);//打印的结果为10---因为这个地址存的内容没有被新的值覆盖
//	}
//	return 0;
//
//}
//空间销毁是指当前程序不再具有使用这块内存的使用权限，还给操作系统了---但是这块空间并没有消失




//指针+-整数
//#include<stdio.h>
//
//int main()
//{
//	float v[5];
//	float* vp;//这个时候，vp还是一个野指针
//	for (vp = &v;vp < &v[5];)//这个时候，vp不再是野指针了，是v【5】首元素的地址（这个数组的下标为0~4）
//	//所以只要在这个数组内部，都会参与循环
//	{
//		*vp++ = 0;//可以分为两部---1.*vp=0（先把0填到数组下标为0的元素中）  2.vp++，再把指针向右移一位
//		//最后把数组的所有元素都填成了0
//	}
//	return 0;
//
//}

//区分
//（*vp）++  ----》先解引用，再（vp指向的对象）++
//  *vp++=0    ----》先vp=0，再vp++


//学了指针后，给数组赋值比较方便了
//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//1.数组下标的写法
//	//for (i = 0;i < sz;i++)
//	//{
//	//	arr[i] = 1;
//	//}
//
//	//指针的写法
//	//int* p = arr;
//	//for (i = 0;i < sz;i++)
//	//{
//	//	*p = 1;
//	//	p++;
//	//}
//
//	int* p = arr;
//	for (i = 0;i < sz;i++)
//	{
//		*(p + 1) = 1;
//	}
//
//	return 0;
//
//}


//两个指针相减

//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n", &arr[9] - &arr[0]);//结果为9
//	//指针减去指针得到的绝对值是指针和指针之间的元素的个数
//	//不是所有的指针都能相减---指向同一块空间的指针相减才有意义
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", &arr[9] - &ch[0]);//错误，没有意义
//	return 0;
//}


//#include<string.h>
//#include<stdio.h>
//int main()
//{
//	int len = strlen("abcdef");
//	printf("%d", len);//字符串的长度---写一个函数模拟这个库函数
//	return 0;
//}

//int my_strlen(char* str)//\0的地址减去首元素的地址即为元素的个数
//{
//	char* start = str;
//	while (*str != '\0')
//	{
//		str++;
//	}
//
//	return (str - start);
//		
//}
//#include<stdio.h>
//int main()
//{
//	int len = my_strlen("abcdef");
//	printf("%d", len);
//	return 0;
//}

//地址加地址，指针加指针是没有意义的（类比日期+日期）


//指针的关系运算---比较大小

//允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，
//但是不允许与指向第一个元素之前的的那个内存位置的指针进行比较


//数组和指针

//数组:一组相同元素的集合
//指针变量:是一个变量，存放的是地址

//联系：
//int*p=arr;
//&arr[i]  和 p+i  和 *（arr+i） 的效果是一样的

//二级指针


//#include<stdio.h>
//
//int main()
//{
//	int a = 0;
//	int* pa = &a;//pa是一个一级指针变量
//	
//	//因为pa也是一个变量
//	//所以pa也有地址
//	int* * ppa=&pa;//ppa是一个二级指针变量
//	//通过ppa要找到a的值，要解引用两次
//
//	**ppa = 20;//这时，a=20
//
//	return 0;
//}

// int * pa----->这里的int指，指针存放的类型是int   *表示这是一个指针  pa是指针变量
//int ** ppa---->这里的int*(第一个*)指，指针指向的类型是int*   *（第二个*）在说明这是一个指针  ppa是二级指针变量
// 
// 二级指针变量是用来存放一级指针变量的地址的


//指针数组
//是一个数组----存放指针的数组

//#include<stdio.h>
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = 30;
//
//	int* pa = &a;
//	int* pb = &b;
//	int* pc = &c;//这样写太麻烦了
//
//	//如果用一个数组来存放就好了
//
//	int* parr[10] = { &a,&b,&c };//parr就是存放指针的数组-----通过这几个指针找到a,b,c的值
//
//	return 0;
//}



//#include<stdio.h>
//
//int main()
//{
//
//	int arr1[4] = { 1,2,3,4 };
//	int arr2[4] = { 1,2,3,4 };
//	int arr3[4] = { 1,2,3,4 };
//
//	int* parr[3] = { arr1,arr2,arr3 };
//	int i = 0;
//	for (i = 0;i < 3;i++)
//	{
//		int j = 0;
//		for (j = 0;j < 4;j++)
//		{
//			printf("%d", parr[i][j]);
//		}
//		printf("\n");//打印的是3行4列的数组
//	}
//	return 0;
//}



//结构体

//结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
//（数组是一组相同类型的集合）

//内置类型---int float 等等
//复杂对象--人：名字，性别，身高。。。
//结构体就是为了描述复杂对象

//结构体的声明
//  struct tag
// {
//    member-list
// }
//  variable-list


//人
//声明的结构体类型struct Peo


//结构体类型---相当于图纸
//struct Peo
//{
//	char name[20];
//	char tele[12];
//	char sex[5];
//	int high;     //这些是成员变量
//};//变量列表可有可无


//struct Peo
//{
//	char name[20];
//	char tele[12];
//	char sex[5];
//	int high;    
//}p1,p2;//p1 p2是使用struct Peo结构类型创建的2个变量---因为放在了{}外面，所以是全局变量
//一般不这样写

//int main()
//{
//
//	//结构体变量--相当于用图纸建的房子
//	struct Peo p1 = { 0 };
//	//一般这样创建变量--局部变量
//
//	return 0;
//}

//结构体里可以出现其他结构体
//结构体类型的成员可以是标量，数组，指针，甚至是其他结构体
struct Peo
{
	char name[20];
	char tele[12];
	char sex[5];
	int high;    
};

struct St
{
	struct Peo p;
	int num;
	float f;
};


print2(struct Peo* sp)//算了，这一块等看完前面回看83
{
	printf()
}
//结构体变量的初始化
int main()
{
	struct Peo p3 = { "张三","123456789","nan",181 };//结构体变量的创建
	struct St s = { {"张三","123456789","nan",181 },100,166};//浮点数在内存中不能精确保存
    return 0;
	print1(&p3);
}


//结构体成员的访问是通过点操作符访问的，点操作符接受两个操作数
//得到的是一个地址用―>


//结构体传参
//1.结构体变量本身    空间的浪费（因为形参会重现开辟一块新的一样大小的空间）
//2.结构体的地址

//函数传参的的时候，参数是需要压栈的
//如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降

//结论，结构体传参的时候，尽量传结构体的地址
