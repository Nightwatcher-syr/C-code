// 递归
//什么是递归
//程序调用自身的编程技巧称为递归，是一种方法，它通常把一个复杂的问题转化为与原问题相似的规模较小的问题来求解，大大减小了代码量
// 核心思想为把大事化小
//

//接收一个整型值（无符号），按照顺序打印他的每一位
//#include<stdio.h>
//int main()
//{
//	unsigned int num = 0;
//	scanf_s("%u", num);//%u是打印无符号的整数，%d是打印有符号的整数
//	//要想得到1234中的4，则%10，剩下的就是4---1234/10就得到了123--用123%10就得到了3--123/10得到了12---12%10就i得到了2---12/10就得到了1
//	//可以看出这是一个循环
//	//但是这样打印的顺序就反了
//	//1.可以先把他存起来，再按照你想知道的打印
//	while (num)
//	{
//		printf("%d", num % 10);
//		num = num / 10;
//	}
//	return 0;
//
//}

//引出递归的实现
//条件是函数--函数的递归
//print(1234)
//print(123)4
//print(12)3 4
//print(1)2 3 4
//1 2 34 

//递归必须满足两个必要条件
//1.有停下来的限制条件
//2.每次递归后都越来越接近这个条件
//不能形成死递归


//void print(unsigned int n)
//{
//	if (n > 9)//如果没有这个条件---就会一直自己调自己---程序会崩溃
//		//调试时显示的错误为Stack overflow---栈溢出
//	{
//		print(n / 10);//再次调用print--此时还没打印，因为还没有调用结束---一直调用print直到n<9才会打印（自己调用自己）---调用多次只打印1
//		//递归---把递归拆解为两个步骤
//		// 递--一个个往下递
//		// 归---再一个个返回
//		//(多层的调用语句）
//
//	}
//	printf("%d\n", n % 10);
//}
//#include<stdio.h>
//int main()
//{
//	unsigned int num = 0;
//	scanf_s("%u", &num);
//	print(num);//这个函数的作用是接受一个整型值（无符号），按照顺序打印他的每一位
//	return 0;
//
//}

//内存中有三个区域
//栈区-----局部变量，函数的形参，每一次函数的调用都会在栈区上申请空间
//堆区
//静态区


//编写函数，不允许创建临时变量，求字符串的长度
//目标为求字符串的长度---目前知道的方法是用strlen函数

//实际上的意思是要模拟一下strlen函数

//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	int len = strlen("abc");
//	printf("%d\n", len);
//	return 0;
//}


//那就模拟一下吧
//以下方法是使用了临时变量的方法

//#include<stdio.h>
//#include<string.h>
////int my_strlen(char arr[])---这是参数的形式   ---下面的是写成指针的形式------这两种形式都行，本质上都一样，只是不同的书写形式而已
//
//int my_strlen(char* str)//存放的是arr的地址
//{
//	int counter = 0;//--这里的counter其实是一个临时变量
//	while (*str != '\0')//注意注意这里不能用双引号，因为双引号是用来括起来字符串的，而\0是一个字符
//	{
//		counter++;
//		str++;//跳过一个字符---一个字符是一个字节
//	}
//	return counter;
//}
//这个函数的逻辑是这样的
//首先，把counter初始化为0，接着，因为字符串的存储也是连着的（别忘了最后还有一个\0)，也就是说实际存储的字符比原来要多一个，那么只要一个接着一个的读取字符，直到读到\0就停止，而每一次读取一个字符即让counter加1
//最后只要输出counter的值就行了
//int main()
//{
//	char arr[] = "abc";
//	int len = my_strlen(arr);
//	printf("%d\n", len);
//	return 0;
//}


//既然讲了递归，就用递归来解决问题
//思考：一个字符串，如果第一个不是\0的话，那么他字符串的长度至少是1
//#include<stdio.h>
//int  my_strlen(char* str)
//{
//	if (*str != '\0')
//	{
//		return 1 + my_strlen(str + 1);//这里不能写成str++因为先str再++，相当于str的值没有变  //也不建议写成++str，虽然在这个程序里面是没错的，但是++str会改变str的值
//		//而单纯的str+1不会改变str的值，只是一个结果
//
//	}
//	else
//		return 0;//return是要向前（其实是一层一层包裹的递的外面一层）返回一个结果0
//}
//
////这就没有创建一个临时变量，满足题目的要求
//int main()
//{
//	char arr[] = "abc";
//	int len = my_strlen(arr);
//	printf("%d\n", len);
//	return 0;
//}

//其实上面的代码可以用循环来实现
//这就提出了一个概念---迭代
//循环是一种迭代，但是迭代不只是循环


//在解决一个问题的时候，其实用循环或者递归都能实现
//比如求n的阶乘
//n！=n*（n-1）！//当n>1时   &   n！=1//当n<=1时
//根据上面的公式可以得到递归的代码
//int fac(int n)
//{
//	if (n <= 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return n * fac(n - 1);
//	}
//}
//#include<stdio.h>
//int main()
//{
//	int n = 0;
//	scanf_s("%d", &n);
//	int ret = fac(n);
//	printf("%d", ret);
//	return 0;
//}
//而用循环的方式在早些的课上已经写过了


//但是没有那个是更好的这个说法
//要是情况来定
//比如下面的一个例子用递归就存在着很大的问题
//计算斐波那契数列（1 1 2 3 5 8 13 21 34 55...)

//int Fib(int n)
//{
//	if (n < 2)
//		return 1;
//	else
//		return Fib(n - 1) + Fib(n - 2);
//}
//#include<stdio.h>
//int main()
//{
//	int n = 0;
//	scanf_s("%d", &n);
//	int ret = Fib(n);
//	printf("%d", ret);
//	return 0;
//}
//这个代码在运行的时候，如果输入的数据比较小，那么会很快得到结果
//但是如果输入的数据很大----比如50，那么一直显示在计算，迟迟得不到结果
//可以引入一个全局变量count，让他来计算到底计算了多少次Fib（3）

/*int count = 0*/;
//int Fib(int n)
//{
//	if (n == 3)
//		count++;
//	if (n < 2)
//		return 1;
//	else
//		return Fib(n - 1) + Fib(n - 2);
//}
//#include<stdio.h>
//int main()
//{
//	int n = 0;
//	scanf_s("%d", &n);
//	int ret = Fib(n);
//	printf("%d  %d", ret,count);//如果输入的数据是40，那么计算的Fib（3）的次数是39088169--太多了，所以计算速度很慢
//	return 0;
//}

//可以稍微分析一下计算的过程
//                                  40
//                           39           38
//                      38      37     37    36
//                   37   36  36 35   36 35 35 34
//               。。。。。。。。。。。。。。。。。。
//造成严重重复计算

//所以用递归来解决这个问题显然不太合适（递归的问题是效率低---原因是每次只能算一次）

//那么就尝试用迭代来解决
//其实斐波那契数列用3个变量就行了
//int Fib(int n)
//{
//	int a = 1;
//	int b = 1;
//	int c = 0;
//	while (n >= 3)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//#include<stdio.h>
//int main()
//{
//	int n = 0;
//	scanf_s("%d", &n);
//	int ret = Fib(n);
//	printf("%d",ret );
//	return 0;
//}
//这样的话，速度就非常快了（因为每次算只用按顺序从后往前计算就行了），（虽然运行结果会出错，但是是因为溢出的问题）

//未来怎么权衡递归和非递归-------实际情况
//递归的优点为，写起来简单且没有明显缺陷    缺点为效率低下
//递归在使用时要注意栈溢出的现象

//汉诺塔问题-----比特大博哥
//青蛙跳台阶问题----刷题训练营



//数组
// 
//（听学姐说数组很重要）



//什么是数组
// 数组是一组相同元素的集合

//int main()
//{
///*	int a = 1;
//	int b = 2;
//	int c = 3;*/
//	//1~100


//数组的创建方式
//type_t arr_name [const_n];
//type_t 是指一个常量表达式 ，用来指定数组的大小
//如下
//	int arr[10];
//	char ch[5];
//	double data[15+5];//语法上支持--可以是一个表达式
//	int n = 1;
//	//int arr[n];    //这里报错了，说arr的表达式必须是一个常量表达式  //只能在支持C99的编译器上进行  //但是这种数组是不能初始化的
//	//在C99之前，数组的大小必须是常量或常量表达式
//	//在C99之后，数组的大小可以是变量，为了支持变长数组（变长数组是指数组的长度是通过变量来决定的）
//
//return 0;
//}
 


//数组的初始化
//是指：在创建数组的同时给数组的内容一些合理的初始值
//e.g.int arr1[10]={1,2,3,4}     char arr2[]="asdf"
//#include<stdio.h>
//int main()
//{
//	int arr1[10] = { 1,2,3 };//没有把10个填满，这个叫不完全初始化，剩下的元素默认初始化为0
//	int arr2[10] = { 1,2,3,4,5,6,7,8,9,10 };//完全初始化
//
//	char arr3[10] = { 'a','b','c' };//处了abc前三个，后面的默认初始化为\0
//	char arr4[10] = "abc";//这样也可以
//	//但是上面两个是有区别的，第一个初始化是自己主动放上去3个字符即abc，后面的7个\0是自动补充上的
//	//而第二个相当于自己主动放上去4个字符即abc\0,而后面的6个\0是自动补充上的
//	//但是放进去的效果是一样的
//
//
//	char arr5[] = { 'a','b','c' };//3个元素   //这种形式要想用字符串的形式打印必须要以\0结尾
//	char arr6[] = "abc";//4个元素‘\0’别忘
//
//
//    return 0;
//}


//一维数组的使用
//对于数组的的使用我们之前介绍了一个操作符【】，他其实就是访问数组的操作符
//#include<stdio.h>
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };//在内存的栈区里面找了连续的空间放置了这10个数值，这些“房间”都是有编号的，这些编号从零开始（这些编号就是数组的下标）
//	//【】是下标引用操作符
//	printf("%d", arr[4]);//下标为4的数字是5
//	//如何求元素个数
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//这个算数组大小的算式我以前一直不太理解，现在理解了
//	//就是sizeof(arr)是算整个数组所占用的字节----比如为40
//	//sizeof(arr[0])是算第一个元素（因为数组是一系列相同类型的元素的集合嘛，所以每一个元素所长用的空间应该相同）所占用空间---比如为4
//	//那么数组的大小就是40/4=10  //十个元素
//	//只要知道下标就可以知道数组的元素
//	return 0;
//1.数组是使用下标来访问的
//2.数组的大小可以通过计算得到


//一维数组在内存中的储存
//可通过实践印证数组的储存是否是连续的pritnf("%d",&arr[i]);     //每一个整形所占的字节为4
//随着数组下标的增长，数组的地址也在有规律的递增


//二维数组的创建与初始化

//二维数组二的创建
//相同的数据出现了好多组---就有了二维数组
//int arr[3][4];//表示是3行4列的数组




//#include<stdio.h>
//int main()
//{
//	int arr[3][4];//三行四列的数组
//	char arr1[5][10];//放5行，每行10个元素
//	return 0;
//}

//二维数组的初始化
//1 2 3 4
//2 3 4 5
//3 4 5 6
//要存放这样一组数

//#include<stdio.h>
//int main()
//{
//	int arr1[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };//因为已经制定好了分组的形式，所以再放置的时候分组就会按照上述的3行4列那样分组
//	//如果不完全初始化，剩下的默认为0
//
//	//如果元素又不够，又想让已知的数据出现在指定的位置
//	int arr2[3][4] = { {1,2},{3,4},{2,3} };//可以做一定的分组---12放在第一行，34放在第二行，23放在第三行
//	int arr3[][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };//可以不指定
//	//int arr4[][] = { {1,2},{3,4},{2,3,4} };//这里报错----因为在二维数组里，行有多少可以省略，但是列数一定要明确的告诉
//	return 0;
//}


//为什么不能省去列？
//自己想一想，如果没有列的话，根本存不了----自己用心体会




//二维数组的使用
//行和列也有自己的编号，都是从0开始----很像矩阵
//可以先确定行，再确定列
//还是通过定位下标的方式来定位元素

//#include<stdio.h>
//int main()
//{
//	int arr1[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };
//	int i = 0;
//	printf("%d", arr1[2][0]);//是3，对了
//    return 0;
//}

//要是想自己输入数据来组成一个二维数组----可以把二维数组看成是一维数组（这个一维数组的每一个元素是一个数组）
//三维数组同理
//#include<stdio.h>
//int main()
//{
//	int arr1[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };//这是初始化，就跟变量初始化一样，最后数组的结果不一定是这个
//	int i = 0;
//	for (i = 0;i < 3;i++)
//	{
//		int j = 0;
//		for (j = 0;j < 4;j++)
//		{
//			scanf_s("%d",&arr1[i][j]);
//		}
//
//	}
//	for (i = 0;i < 3;i++)
//	{
//		int j = 0;
//		for (j = 0;j < 4;j++)
//		{
//		printf("%d ", arr1[i][j]);
//		}
//		printf("\n");//被忘了
//	}
//
//	return 0;
//}


//二维数组在内存中的存储
#include<stdio.h>
int main()
{
	int arr1[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 };//
	int i = 0;
for (i = 0;i < 3;i++)
	{
		int j = 0;
		for (j = 0;j < 4;j++)
		{
			printf("&arr[%d][%d]=%p\n", i, j, &arr1[i][j]);
		}
		
	}

	return 0;
}
//& arr[0][0] = 00000094C66FFA88
//& arr[0][1] = 00000094C66FFA8C
//& arr[0][2] = 00000094C66FFA90
//& arr[0][3] = 00000094C66FFA94
//& arr[1][0] = 00000094C66FFA98
//& arr[1][1] = 00000094C66FFA9C
//& arr[1][2] = 00000094C66FFAA0
//& arr[1][3] = 00000094C66FFAA4
//& arr[2][0] = 00000094C66FFAA8
//& arr[2][1] = 00000094C66FFAAC
//& arr[2][2] = 00000094C66FFAB0
//& arr[2][3] = 00000094C66FFAB4
//这是运行的结果，观察可得 一行每个元素之间差4个字节，第一行最后一个和下一行第一个之间也差4








